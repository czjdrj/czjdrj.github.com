<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>拖拽展示效果</title>
<style>
body{
	background:#333;
}
*{
	margin:0;
	padding:0;
	list-style:none;
}
#tips{
	width:300px;
	position:absolute;
	left:0;
	top:100px;
}
#tips p{
	font-size:16px;
	margin:10px;
	color:#fff;
}
#div1{
	width:600px;
	height:280px;
	margin:150px 400px;
	position:relative;
	background:#999;
	overflow:hidden;
}
#div1 ul{
	position:absolute;
	left:0px;
	top:86px;
}
#div1 ul li{
	width:110px;
	height:110px;
	float:left;
	/*background:red;*/
	position:relative;
	cursor:pointer;
}
#div1 ul li img{
	width:110px;
	height:110px;
	opacity:1;
}
/*#div1 ul li span{
	position:absolute;
	left:50%;
	top:50%;
	background:#fff;
	font-size:30px;
}*/
</style>
<script>
window.onload=function(){
	var oDiv=document.getElementById("div1");
	var oUl=oDiv.children[0];
	var aLi=oUl.children;
	var aImg=oUl.getElementsByTagName("img");
	var aSpan=oUl.getElementsByTagName("span");
	
	oUl.style.width=oUl.children.length*110+"px";
	oUl.onmousedown=function(ev){
		var e=ev||event;
		var disX=e.clientX-oUl.offsetLeft;
		
		document.onmousemove=function(ev){
			var e=ev||event;
			var l=e.clientX-disX;
			//限定可拖拽距离
			if(l>oDiv.offsetWidth/2-(0+0.5)*aLi[0].offsetWidth){
				l=oDiv.offsetWidth/2-(0+0.5)*aLi[0].offsetWidth;
			}
			if(l<oDiv.offsetWidth/2-(aLi.length-1+0.5)*aLi[0].offsetWidth){
				l=oDiv.offsetWidth/2-(aLi.length-1+0.5)*aLi[0].offsetWidth;
			}
			//使用
			oUl.style.left=l+"px";
			//计算图片大小的函数
			setSize();
		}
		
		document.onmouseup=function(){
			document.onmousemove=null;
			document.onmouseup=null;
			oUl.releaseCapture&&oUl.releaseCapture();
		}
		oUl.setCapture&&oUl.setCapture();
		return false;
	}
	//设置中间默认的图片
	setCenter(3);
	function setCenter(n){
		oUl.style.left=oDiv.offsetWidth/2-(n+0.5)*aLi[0].offsetWidth+"px";
	}
	//调用函数初始化一下大小
	setSize();
	function setSize(){
		//求到中心点距离
		for(var i=0;i<aLi.length;i++){
			var dis=oDiv.offsetWidth/2-(oUl.offsetLeft+aLi[i].offsetLeft+aLi[i].offsetWidth/2);
			dis=Math.abs(dis);
			//这个距离必须是正数
			var scale=1-dis/1000;
			//800是随便设定的总路程 比值=已走路程/总路程
			if(scale<0.5) scale=0.5;
			//因为每个图片缩小后的距离过大，限制缩放比在0.5-1之间
			aImg[i].style.width=220*scale+"px";
			aImg[i].style.height=220*scale+"px";
			//用比值控制图片的宽高
			aImg[i].style.marginLeft=-(aImg[i].offsetWidth-aLi[i].offsetWidth)/2+"px";
			aImg[i].style.marginTop=-(aImg[i].offsetHeight-aLi[i].offsetHeight)/2+"px";
			//调整图片放大后的位置，为了保持在中间
			aLi[i].style.zIndex=parseInt(scale*10);
			//越到中间，比值越大，层级直接等于正数的比值就可以了
			aLi[i].style.opacity=scale;
			//比值刚好和透明度一样，都是0-1之间，直接用
			//aSpan[i].innerHTML=scale.toFixed(2);
		}
	}
	window.onresize=setSize;
}
</script>
</head>

<body>
<div id="tips">
	<p>展示效果</p>
	<p>实现原理:</p>
	<p>1、布局:一般常见轮播图的布局。</p>
	<p>2、js:拖拽整个ul，限定可拖拽的最大距离。</p>
	<p>3、js:求距离dis，需要求得每个li的中心点，到整个div的中心点的距离（距离有正负之分，必须绝对值）；假设这个距离是已走的路程，再假设一个总路程如1000（感应范围），会得出一个比值=dis/200，意思是在1000范围内，每个li越靠近div中线，比值就越小；然而需要的效果正好相反，因此要用1-比值，这时li越靠近div中线，比值就越大。</p>
	<p>4、js:使用这个比值来控制每个li的宽高、层级、透明度。</p>
</div>
<div id="div1">
	<ul>
    	<li><img src="img3/1.jpg"/><span></span></li>
    	<li><img src="img3/2.jpg"/><span></span></li>
    	<li><img src="img3/3.jpg"/><span></span></li>
    	<li><img src="img3/4.jpg"/><span></span></li>
    	<li><img src="img3/5.jpg"/><span></span></li>
    	<li><img src="img3/6.jpg"/><span></span></li>
    	<li><img src="img3/7.jpg"/><span></span></li>
    </ul>
</div>
</body>
</html>
